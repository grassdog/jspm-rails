/* */ 
var React = require("react");
var warning = require("react/lib/warning");
var invariant = require("react/lib/invariant");
var DefaultRoute = require("../components/DefaultRoute");
var NotFoundRoute = require("../components/NotFoundRoute");
var Redirect = require("../components/Redirect");
var Route = require("../components/Route");
var Path = require("./Path");
var CONFIG_ELEMENT_TYPES = [DefaultRoute.type, NotFoundRoute.type, Redirect.type, Route.type];
function createRedirectHandler(to, _params, _query) {
  return React.createClass({
    statics: {willTransitionTo: function(transition, params, query) {
        transition.redirect(to, _params || params, _query || query);
      }},
    render: function() {
      return null;
    }
  });
}
function checkPropTypes(componentName, propTypes, props) {
  for (var propName in propTypes) {
    if (propTypes.hasOwnProperty(propName)) {
      var error = propTypes[propName](props, propName, componentName);
      if (error instanceof Error)
        warning(false, error.message);
    }
  }
}
function createRoute(element, parentRoute, namedRoutes) {
  var type = element.type;
  var props = element.props;
  var componentName = (type && type.displayName) || 'UnknownComponent';
  invariant(CONFIG_ELEMENT_TYPES.indexOf(type) !== -1, 'Unrecognized route configuration element "<%s>"', componentName);
  if (type.propTypes)
    checkPropTypes(componentName, type.propTypes, props);
  var route = {name: props.name};
  if (props.ignoreScrollBehavior) {
    route.ignoreScrollBehavior = true;
  }
  if (type === Redirect.type) {
    route.handler = createRedirectHandler(props.to, props.params, props.query);
    props.path = props.path || props.from || '*';
  } else {
    route.handler = props.handler;
  }
  var parentPath = (parentRoute && parentRoute.path) || '/';
  if ((props.path || props.name) && type !== DefaultRoute.type && type !== NotFoundRoute.type) {
    var path = props.path || props.name;
    if (!Path.isAbsolute(path))
      path = Path.join(parentPath, path);
    route.path = Path.normalize(path);
  } else {
    route.path = parentPath;
    if (type === NotFoundRoute.type)
      route.path += '*';
  }
  route.paramNames = Path.extractParamNames(route.path);
  if (parentRoute && Array.isArray(parentRoute.paramNames)) {
    parentRoute.paramNames.forEach(function(paramName) {
      invariant(route.paramNames.indexOf(paramName) !== -1, 'The nested route path "%s" is missing the "%s" parameter of its parent path "%s"', route.path, paramName, parentRoute.path);
    });
  }
  if (props.name) {
    invariant(namedRoutes[props.name] == null, 'You cannot use the name "%s" for more than one route', props.name);
    namedRoutes[props.name] = route;
  }
  if (type === NotFoundRoute.type) {
    invariant(parentRoute, '<NotFoundRoute> must have a parent <Route>');
    invariant(parentRoute.notFoundRoute == null, 'You may not have more than one <NotFoundRoute> per <Route>');
    parentRoute.notFoundRoute = route;
    return null;
  }
  if (type === DefaultRoute.type) {
    invariant(parentRoute, '<DefaultRoute> must have a parent <Route>');
    invariant(parentRoute.defaultRoute == null, 'You may not have more than one <DefaultRoute> per <Route>');
    parentRoute.defaultRoute = route;
    return null;
  }
  route.childRoutes = createRoutesFromChildren(props.children, route, namedRoutes);
  return route;
}
function createRoutesFromChildren(children, parentRoute, namedRoutes) {
  var routes = [];
  React.Children.forEach(children, function(child) {
    if (child = createRoute(child, parentRoute, namedRoutes))
      routes.push(child);
  });
  return routes;
}
module.exports = createRoutesFromChildren;
